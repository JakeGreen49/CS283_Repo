1. In this assignment I suggested you use `fgets()` to get user input in the main while loop. Why is `fgets()` a good choice for this application?

    > **Answer**:  _fgets() is a good choice because its default behavior is to read data from a file stream, stop reading when a newline character is encountered, and store all the read characters in a buffer. By specifying the file stream to be stdin, the fgets function will behave in a manner conducive to a shell program: it will wait for user input, and when the enter key is pressed, it will store the input in a buffer to then be processed by the program. Moreover, fgets will read the newline into the buffer, in contrast to something like scanf() which does not; this means the newline can be safely removed when using fgets and won't cause any issues when reading in the next user input._

2. You needed to use `malloc()` to allocte memory for `cmd_buff` in `dsh_cli.c`. Can you explain why you needed to do that, instead of allocating a fixed-size array?

    > **Answer**:  _A fixed-size array is allocated on the stack, and as such that memory will stay in use until the function in which it was allocated finishes running. Normally this is not much of a problem, but in this program we are looping in main until the user tells the program to stop with the 'exit' command. So, if we were allocating our buffer as a fixed-size array in the main loop, the program's memory usage would grow by the size of that buffer after each command which can become extremely costly depending on how long the program runs. Even if the array was allocated outside of the main loop to avoid this memory issue, we would have to dedicate time to reseting each character of the buffer at the end of the loop. If instead we allocate the buffer on the heap, as we did, you can free the memory at the end of the loop so that our program is only ever dedicating one buffer's worth of memory for reading in the user input._

3. In `dshlib.c`, the function `build_cmd_list(`)` must trim leading and trailing spaces from each command before storing it. Why is this necessary? If we didn't trim spaces, what kind of issues might arise when executing commands in our shell?

    > **Answer**:  _The typical behavior for command prompts is to tokenize by spaces, so extra leading or trailing spaces would mess up this tokenization. If leading spaces were left in, the shell would interpret the command to be empty, and any extra spaces would result in the shell interpreting them as arguments to the command. Since this is not desired behavior, it is necessary to trim the leading and trailing spaces before storing the command._

4. For this question you need to do some research on STDIN, STDOUT, and STDERR in Linux. We've learned this week that shells are "robust brokers of input and output". Google _"linux shell stdin stdout stderr explained"_ to get started.

- One topic you should have found information on is "redirection". Please provide at least 3 redirection examples that we should implement in our custom shell, and explain what challenges we might have implementing them.

    > **Answer**:  _One redirection we should implement in our shell is redirecting a command's output (its stdout) into a file. The challenges that this redirection would pose would be properly handling the file and deciding what should happen if the specified file already contains stuff in it. Another redirection we should implement is redirecting the error messages a command may output (its stderr) to a file independent of its output. The challenges for this redirection would be similar to the redirection of the output, as well as keeping this redirection separate from the output if both were desired at once. A third redirection we should implement is redirecting the contents of a file into the input of a command (its stdin). The challenges that this redirection pose include properly handling the contents of the file and defining what to do when a file contains holes._

- You should have also learned about "pipes". Redirection and piping both involve controlling input and output in the shell, but they serve different purposes. Explain the key differences between redirection and piping.

    > **Answer**:  _Pipes can be either unnamed or named. An unnamed pipe is a special kind of redirection that redirects the STDOUT of one command into the STDIN of another; so, rather than redirecting into a file for storage like the redirections discussed above, an unnamed pipe redirects outputs for further processing of another command. A named pipe is a special kind of file whose contents reside in memory instead of being written on the disk; information can be redirected into and out of the pipe at will, unlike the unnamed pipe that redirects outputs immediately. Named pipes are much more distinct from redirection, as they are treated as a file by the operating system, so once made they exist until they are removed. The big advantage of using a named pipe is that it is a much less costly way to store and transfer temporary information, costing far less I/O operations than creating a normal file to redirect into._

- STDERR is often used for error messages, while STDOUT is for regular output. Why is it important to keep these separate in a shell?

    > **Answer**:  _Keeping STDERR and STDOUT separate is important because a command might produce both an output and an error message, and when that happens we want to keep them separate so we can distinguish the two. A great example of where this would be desirable is in piping an output into another command; we would want to keep the output separate from any error messages so that the command would not have to worry about dealing with the error message._

- How should our custom shell handle errors from commands that fail? Consider cases where a command outputs both STDOUT and STDERR. Should we provide a way to merge them, and if so, how?

    > **Answer**:  _I think that the default behavior should be to print both the error and the output in the shell, but they should absolutely be kept in separate channels, just as STDOUT and STDERR are. That way, if a user wants to segregate them in some way (ie. redirect the output into a file but still allow error messages to print in the shell) it is far easier to implement. To that end, I do not think that the error messages and the outputs should be merged in our code to make segregating them far easier to implement, but if the user wants to redirect them both into the same file, we should provide a way to do that. Doing so could probably look a lot like it does in Linux shells, where we specify the redirections of STDOUT and STDERR separately and name the file to redirect into; in the case of redirecting them into the same file, that could look something like "cmd out> file.txt err> file.txt", which would separately redirect the output and the error message into the same file._
