1. Your shell forks multiple child processes when executing piped commands. How does your implementation ensure that all child processes complete before the shell continues accepting user input? What would happen if you forgot to call waitpid() on all child processes?

_My implementation stores all of the PIDs of the children processes in an array, then uses waitpid() while looping through that array in order to ensure all of the child processes have finished running before the shell resumes. If this was not done, then one or more child processes could be running along side the parent process, leading to unexpected behavior (for instance, two or more outputs being printed after running a command or having to call exit more than one time to exit the shell)._

2. The dup2() function is used to redirect input and output file descriptors. Explain why it is necessary to close unused pipe ends after calling dup2(). What could go wrong if you leave pipes open?

_It is necessary to close unused pipe ends after calling dup2() because those pipe ends are no longer needed, and continuing to leave them open might cause issues. For instance, leaving the unused pipe ends open might cause one of the processes to continue waiting for data flow from the other process, leading to a stall in the program. Additionally, there is a maximum number of file descriptors on Linux, and leaving unused pipe ends open might cause this maximum to be reached, making further operations with files difficult or impossible._

3. Your shell recognizes built-in commands (cd, exit, dragon). Unlike external commands, built-in commands do not require execvp(). Why is cd implemented as a built-in rather than an external command? What challenges would arise if cd were implemented as an external process?

_cd is implemented as a built-in command because it needs to change the working directory of the shell itself, and this cannot be done from a child process in the same way that we execute external commands. The shell is running as a parent process, and when we execute external commands we fork into a child process; if we were to try to execute the cd command in this child process, it would only change the child process's working directory, and leave us in the same directory when we return to the parent process. If we wanted to make cd an external command, we would have to find some way to influence the parent process from within a child process, and this is far more work than simply implementing cd as a built-in command._

4. Currently, your shell supports a fixed number of piped commands (CMD_MAX). How would you modify your implementation to allow an arbitrary number of piped commands while still handling memory allocation efficiently? What trade-offs would you need to consider?

_In order to handle an arbitrary number of piped commands, we could instead dynamically allocate the memory inside the command list structure. What this might look like is that initially, the command list can hold one command, but every time another command is added the space is doubled, at first to two commands, then to four, then eight, and so on. The downside of this implementation is that each time the size of the command list is doubled, we have to copy the existing command list into the newly doubled one; this makes the execution of longer pipes take far longer, especially if we start with a max capacity of 1. So, before switching to this implementation, we would need to consider whether the slower runtime is worth having an arbitrary number of piped commands._
